use_mit_license()
## HW5 Class/Methods
setClass(
Class = "sparse_numeric",
slots = c(
value = "numeric",
pos = "integer",
length = "integer"
)
)
setValidity(
Class = "sparse_numeric",
method = function(object){
if (!is.numeric(object@value)){
return("error: value must be numeric")
}
if (length(object@pos) == 0) {
return("error: all zero vector")
}
if (object@length < max(object@pos)){
return("error: set length is not appropriate ")
}
TRUE
}
)
# coerce numeric to sparse_numeric and vice versa
setAs(
from = "numeric",
to = "sparse_numeric",
def = function(from){
# extract the numbers in the vector that are not 0
num_pos <- which(from != 0)
num_val <- from[num_pos]
new("sparse_numeric",
value = num_val,
pos = as.integer(num_pos),
length = length(from))
}
)
setAs(
from = "sparse_numeric",
to = "numeric",
def = function(from){
# make result the length of vector, filling the values of their given position
result <- numeric(from@length)
result[from@pos] <- from@value
result
}
)
# generic functions
setGeneric(
"sparse_add",
def = function(x,y){
standardGeneric("sparse_add")
}
)
setGeneric(
"sparse_sub",
def = function(x,y){
standardGeneric("sparse_sub")
}
)
setGeneric(
"sparse_mult",
def = function(x,y){
standardGeneric("sparse_mult")
}
)
setGeneric(
"sparse_crossprod",
def = function(x,y){
standardGeneric("sparse_crossprod")
}
)
setGeneric(
"sparse_div",
function(x, y) {
standardGeneric("sparse_div")
}
)
setGeneric(
"norm",
function(x) {
standardGeneric("norm")
}
)
setGeneric(
"standardize",
function(x){
standardGeneric("standardize")
}
)
# specific method functions
setMethod(
"sparse_add",
c("sparse_numeric", "sparse_numeric"),
function(x,y){
# check to make sure they are the same length
if (x@length!= y@length)
stop("vectors are not the same length")
# convert to data frames to enable merging
df_x <- data.frame(pos = x@pos, value = x@value)
df_y <- data.frame(pos = y@pos, value = y@value)
# outer join
df_both <- merge(df_x, df_y, by = "pos", all=TRUE)
# replace na values with 0
df_both[is.na(df_both)] <- 0
# add values of the same position
df_both$result <- df_both$value.x + df_both$value.y
# get rid of elements that added to 0
df_both <- df_both[df_both$result  != 0,]
# result vector
new("sparse_numeric",
value = df_both$result,
pos = as.integer(df_both$pos),
length = (x@length))
}
)
setMethod(
"sparse_sub",
c("sparse_numeric", "sparse_numeric"),
function(x,y){
# check to make sure they are the same length
if (x@length!= y@length)
stop("vectors are not the same length")
# convert to data frames to enable merging
df_x <- data.frame(pos = x@pos, value = x@value)
df_y <- data.frame(pos = y@pos, value = y@value)
# outer join
df_both <- merge(df_x, df_y, by = "pos", all=TRUE)
# replace na values with 0
df_both[is.na(df_both)] <- 0
# subtract values of the same position
df_both$result <- df_both$value.x - df_both$value.y
# get rid of elements that subtracted to 0
df_both <- df_both[df_both$result  != 0,]
# result vector
new("sparse_numeric",
value = df_both$result,
pos = as.integer(df_both$pos),
length = (x@length))
}
)
setMethod(
"sparse_mult",
c("sparse_numeric", "sparse_numeric"),
function(x,y){
# check to make sure they are the same length
if (x@length!= y@length)
stop("vectors are not the same length")
# convert to data frames to enable merging
df_x <- data.frame(pos = x@pos, value = x@value)
df_y <- data.frame(pos = y@pos, value = y@value)
# outer join
df_both <- merge(df_x, df_y, by = "pos", all=TRUE)
# replace na values with 0
df_both[is.na(df_both)] <- 0
# multiply values of the same position
df_both$result <- df_both$value.x * df_both$value.y
# result vector
new("sparse_numeric",
value = df_both$result,
pos = as.integer(df_both$pos),
length = (x@length))
}
)
setMethod(
"sparse_crossprod",
c("sparse_numeric", "sparse_numeric"),
function(x,y){
# check to make sure they are the same length
if (x@length!= y@length)
stop("vectors are not the same length")
# convert to data frames to enable merging
df_x <- data.frame(pos = x@pos, value = x@value)
df_y <- data.frame(pos = y@pos, value = y@value)
# join
df_both <- merge(df_x, df_y, by = "pos")
# multiply values of the same position
df_both$result <- df_both$value.x * df_both$value.y
# add up to get cross product
result <- sum(df_both$result)
# result vector
result
}
)
setMethod(
"sparse_div",
c("sparse_numeric", "sparse_numeric"),
function(x,y){
# check to make sure they are the same length
if (x@length!= y@length)
stop("vectors are not the same length")
# convert to data frames to enable merging
df_x <- data.frame(pos = x@pos, value = x@value)
df_y <- data.frame(pos = y@pos, value = y@value)
# join
df_both <- merge(df_x, df_y, by = "pos")
# divide values of the same position
df_both$result <- df_both$value.x / df_both$value.y
# result vector
new("sparse_numeric",
value = df_both$result,
pos = as.integer(df_both$pos),
length = (x@length))
}
)
setMethod(
"mean",
"sparse_numeric",
function(x){
sum(x@value)/x@length
}
)
setMethod(
"norm",
"sparse_numeric",
function(x){
x_2 <- x@value^2
sqrt(sum(x_2))
}
)
setMethod(
"standardize",
"sparse_numeric",
function(x){
mean <- mean(x)
sd_1_2 <- (x@value - mean)^2
sd_1 <- sum(sd_1_2)
# can't just use x@value because this excludes the zeroes
zeroes <- x@length - length(x@value)
sd_2_2 <- (mean)^2
sd_2 <- sd_1 + sd_2_2*zeroes
sd <- sqrt(sd_2/x@length)
stand <- (x@value - mean)/sd
# result vector
new("sparse_numeric",
value = stand,
pos = x@pos,
length = (x@length))
}
)
# methods for signs: +, -, *
setMethod(
"+",
signature(e1 = "sparse_numeric", e2 = "sparse_numeric"),
function(e1, e2){
sparse_add(e1, e2)
}
)
setMethod(
"-",
signature(e1 = "sparse_numeric", e2 = "sparse_numeric"),
function(e1, e2){
sparse_sub(e1, e2)
}
)
setMethod(
"*",
signature(e1 = "sparse_numeric", e2 = "sparse_numeric"),
function(e1, e2){
sparse_mult(e1, e2)
}
)
# method for show and plot
setMethod(
"show",
"sparse_numeric",
function(object){
cat("Values: ", object@value, "\n")
cat("Positions of non-zero values: ", object@pos, "\n")
cat("Vector length: ", object@length, "\n")
}
)
setMethod(
"plot",
c("sparse_numeric","sparse_numeric"),
function(x,y){
# check to make sure they are the same length
if (x@length!= y@length)
stop("vectors are not the same length")
# convert to data frames to enable merging
df_x <- data.frame(pos = x@pos, value = x@value)
df_y <- data.frame(pos = y@pos, value = y@value)
# outer join
df_both <- merge(df_x, df_y, by = "pos")
# find y range
if (min(df_both$value.x) < min(df_both$value.y)){
low_y <- min(df_both$value.x)
} else {
low_y <- min(df_both$value.y)
}
if (max(df_both$value.x) > max(df_both$value.y)){
high_y <- max(df_both$value.x)
} else {
high_y <- max(df_both$value.y)
}
y_range <- c(low_y, high_y)
plot(df_both$pos, df_both$value.x, col = "red", type="p", pch=16, ylim=y_range, xlab="position", ylab="value")
points(df_both$pos, df_both$value.y, col = "blue", pch=16)
}
)
use_readme_rmd()
library(usethis)
use_readme_md()
